// This file is part of VFolders.
// Copyright 2025 by FatihCoskun.

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// at your option any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

#include "CommonData.h"
#include <fstream>
#include <iostream>
#include "Shlwapi.h"
#include "Translator.h"
#include "resource.h"




namespace {

    const char configFor[] = "VFolders";  // identifying string for this plugin

    constexpr int configVersion    = 1;  // version of configuration file expected and generated by this plugin version
    constexpr int configCompatible = 1;  // lowest configuration code version that can read files from this plugin version

    std::wstring filePath;
    bool configFound = false;
    bool configIgnored = false;
    std::filesystem::file_time_type lastWriteTime;

}

using json = nlohmann::json;

json configuration;
void loadShortcuts(string langFilePath);



void loadConfiguration() {

    filePath.resize(npp(NPPM_GETPLUGINSCONFIGDIR, 0, 0), 0);
    npp(NPPM_GETPLUGINSCONFIGDIR, filePath.length() + 1, filePath.data());
    if (PathFileExists(filePath.data()) == FALSE) if (!CreateDirectory(filePath.data(), NULL)) return;
    filePath += L"\\VFolders.json";
    std::ifstream file(filePath);
    if (!file) return;

    configFound = true;
    std::error_code ec;
    lastWriteTime = std::filesystem::last_write_time(filePath, ec);

    json saved = json::parse(file, 0, false, true);

    if (saved.is_discarded()) {
        MessageBox(plugin.nppData._nppHandle,
            L"A configuration file was found, but it does not contain valid JSON and will be ignored.",
            L"VFolders", MB_ICONWARNING);
        configIgnored = true;
        return;
    }

    if (!saved.contains("*ConfigurationFor*") || !saved["*ConfigurationFor*"].is_string() 
      || saved["*ConfigurationFor*"] != configFor) {
        MessageBox(plugin.nppData._nppHandle,
            L"A configuration file was found, but it does not appear to be for this plugin and will be ignored.",
            L"VFolders", MB_ICONWARNING);
        configIgnored = true;
        return;
    }

    if (saved.contains("*ConfigurationCompatibleVersion*")) {
         const auto& ccv = saved["*ConfigurationCompatibleVersion*"];
         if (!ccv.is_number() || ccv.get<int>() > configVersion) {
             MessageBox(plugin.nppData._nppHandle,
                 L"A configuration file was found, but it is for a newer version of this plugin and will be ignored.",
                 L"VFolders", MB_ICONWARNING);
             configIgnored = true;
             return;
         }
    }

    if (saved.contains("overrideShortcuts")) {
        plugin.isShortcutOverridden = saved["overrideShortcuts"];
    }

    if (saved.contains("fontSize")) {
        commonData.fontSize = saved["fontSize"];
	}

    // If changes may be needed to accommodate old versions of the configuration file,
    // check saved["ConfigurationVersion"] here and make adjustments

    configuration.merge_patch(saved);

    // If there are settings you want to copy immediately from the JSON store (configuration)
    // to program storage, do that here.

}


void saveConfiguration() {

    // If you have settings that are not copied to the JSON store whenever they change, copy them here.

    if (configFound) {
        if (configIgnored) {
            if (MessageBox(plugin.nppData._nppHandle,
                L"A configuration file found at startup was ignored because this plugin could not use it.\n\n"
                L"Do you want to save the current configuration settings? (If Yes, the old file will be overwritten.)",
                L"VFolders", MB_YESNO | MB_ICONWARNING) == IDNO) return;
        }
        else {
            std::error_code ec;
            if (lastWriteTime != std::filesystem::last_write_time(filePath, ec)) {
                if (MessageBox(plugin.nppData._nppHandle,
                    L"It looks like the configuration file for this plugin was edited during this session.\n\n"
                    L"Do you want to save the current configuration settings? (If Yes, the edited file will be overwritten.)",
                    L"VFolders", MB_YESNO | MB_DEFBUTTON2 | MB_ICONWARNING) == IDNO) return;
            }
        }
    }

    std::ofstream file(filePath);
    if (!file) return;

    configuration["*ConfigurationFor*"              ] = configFor;
    configuration["*ConfigurationVersion*"          ] = configVersion;
    configuration["*ConfigurationCompatibleVersion*"] = configCompatible;
    configuration["overrideShortcuts"] = plugin.isShortcutOverridden;
	configuration["fontSize"] = commonData.fontSize.get();


    file << std::setw(4) << configuration;

    
    writeJsonFile();
}

wchar_t* getPluginHomePath() {
    int len = (int)::SendMessage(plugin.nppData._nppHandle, NPPM_GETPLUGINHOMEPATH, 0, 0);
    wchar_t* pluginPath = new wchar_t[len + 1];
    ::SendMessage(plugin.nppData._nppHandle, NPPM_GETPLUGINHOMEPATH, len + 1, (LPARAM)pluginPath);
    return pluginPath;
}

void loadLocalization() {
    wchar_t* pluginPath = getPluginHomePath();

    // Get the native language file name from Notepad++
    int len = (int)::SendMessage(plugin.nppData._nppHandle, NPPM_GETNATIVELANGFILENAME, 0, 0);
    std::vector<char> langFileNameVector(len + 1);
    ::SendMessage(plugin.nppData._nppHandle, NPPM_GETNATIVELANGFILENAME, len + 1, (LPARAM)langFileNameVector.data());
    langFileNameVector[len] = L'\0';
    string langFileName = langFileNameVector.data();

    LOG("Native Lang file name: [{}]", langFileName);

	string langFilePath;
    if (langFileName.find_last_of("/\\") != string::npos) {
		langFilePath = langFileName;
        size_t lastSlash = langFileName.find_last_of("/\\");
        langFileName = langFileName.substr(lastSlash + 1);
    }
    else {
        TCHAR nppDir[MAX_PATH];
        SendMessage(plugin.nppData._nppHandle, NPPM_GETNPPDIRECTORY, (WPARAM)MAX_PATH, (LPARAM)nppDir);
        langFilePath = fromWchar(nppDir) + "\\localization\\" + langFileName;
    }

	// Parse commands from native lang file
	commonData.nativeTranslator = std::make_unique<Translator>(langFilePath);

    loadShortcuts(langFilePath);
    


    // Check for external lang file in plugin's localization folder
    std::string externalLangFilePath = fromWchar(pluginPath) + "\\VFolders\\localization\\" + langFileName;
    if (std::filesystem::exists(externalLangFilePath)) {
        Translator translator(externalLangFilePath);
        commonData.translator = std::make_unique<Translator>(externalLangFilePath);
    }
    else {
        // If no external file, load from resources
        std::transform(langFileName.begin(), langFileName.end(), langFileName.begin(), ::tolower);
        if (langFileName == "turkish.xml") {
            commonData.translator = std::make_unique<Translator>(plugin.dllInstance, IDR_LANG_TURKISH);
        }
        else if (langFileName == "english.xml") {
            commonData.translator = std::make_unique<Translator>(plugin.dllInstance, IDR_LANG_ENGLISH);

        }
    }



    /*HRSRC hRes = FindResource(plugin.dllInstance, MAKEINTRESOURCE(IDR_LANG_ENGLISH), RT_RCDATA);
    HGLOBAL hData = LoadResource(plugin.dllInstance, hRes);
    DWORD size = SizeofResource(plugin.dllInstance, hRes);
    const char* xmlData = static_cast<const char*>(LockResource(hData));


    std::string langXml(xmlData, size);*/

}

void loadShortcuts(string langFilePath)
{
    commonData.shortcutTranslator = std::make_unique<Translator>(langFilePath + "\\shortcuts.xml");

    TCHAR configDir[MAX_PATH];
    SendMessage(plugin.nppData._nppHandle, NPPM_GETPLUGINSCONFIGDIR, (WPARAM)MAX_PATH, (LPARAM)configDir);
    std::filesystem::path pluginDir = std::filesystem::path(configDir).parent_path();
    std::filesystem::path userShortcuts = pluginDir.parent_path() / L"shortcuts.xml";
    string shortcutPath = userShortcuts.string();
    if (std::filesystem::exists(shortcutPath)) {
        Translator translator(shortcutPath);
		commonData.shortcutTranslator.get()->loadFile(shortcutPath);
	}

}